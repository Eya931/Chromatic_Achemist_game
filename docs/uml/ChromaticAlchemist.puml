@startuml ChromaticAlchemist
!theme plain
skinparam classAttributeIconSize 0
skinparam classFontSize 12
skinparam packageFontSize 14
skinparam linetype ortho

title Chromatic Alchemist - Design Patterns UML Diagram

' ========================================
'           STATE PATTERN
' ========================================
package "State Pattern" #LightBlue {
    
    interface ElementalState <<interface>> {
        +canAbsorb(color: String): boolean
        +getCompatibleColors(): String[]
        +getSpeedModifier(): double
        +useSpecialAbility(player: Player): void
        +getAbilityName(): String
        +getAbilityCooldown(): double
        +getStateName(): String
        +getStateColor(): String
        +getGlowColor(): String
    }
    
    class FireState {
        -compatibleColors: String[]
        +canAbsorb(color: String): boolean
        +getSpeedModifier(): double
        +useSpecialAbility(player: Player): void
        +getAbilityName(): String
    }
    
    class WaterState {
        -compatibleColors: String[]
        +canAbsorb(color: String): boolean
        +getSpeedModifier(): double
        +useSpecialAbility(player: Player): void
        +getAbilityName(): String
    }
    
    class EarthState {
        -compatibleColors: String[]
        +canAbsorb(color: String): boolean
        +getSpeedModifier(): double
        +useSpecialAbility(player: Player): void
        +getAbilityName(): String
    }
    
    class AirState {
        -compatibleColors: String[]
        +canAbsorb(color: String): boolean
        +getSpeedModifier(): double
        +useSpecialAbility(player: Player): void
        +getAbilityName(): String
    }
    
    enum GameState <<enum>> {
        MENU
        PLAYING
        PAUSED
        GAME_OVER
        VICTORY
        OPTIONS
    }
    
    ElementalState <|.. FireState
    ElementalState <|.. WaterState
    ElementalState <|.. EarthState
    ElementalState <|.. AirState
}

' ========================================
'           DECORATOR PATTERN
' ========================================
package "Decorator Pattern" #LightGreen {
    
    interface PlayerAbility <<interface>> {
        +getSpeed(): double
        +getAbsorptionRange(): double
        +getShieldValue(): double
        +getScoreMultiplier(): double
        +canMultiAbsorb(): boolean
        +getMagnetStrength(): double
        +getDescription(): String
    }
    
    class BasePlayerAbility {
        -baseSpeed: double
        -baseRange: double
        +getSpeed(): double
        +getAbsorptionRange(): double
        +getShieldValue(): double
        +getScoreMultiplier(): double
    }
    
    abstract class AbilityDecorator {
        #wrappedAbility: PlayerAbility
        #duration: double
        #remainingTime: double
        +AbilityDecorator(ability: PlayerAbility, duration: double)
        +update(deltaTime: double): void
        +isExpired(): boolean
        +getDecoratorName(): String
    }
    
    class SpeedBoostDecorator {
        -SPEED_MULTIPLIER: double
        +getSpeed(): double
        +getDecoratorName(): String
    }
    
    class ShieldDecorator {
        -SHIELD_VALUE: double
        +getShieldValue(): double
        +getDecoratorName(): String
    }
    
    class MagnetDecorator {
        -MAGNET_STRENGTH: double
        +getMagnetStrength(): double
        +getDecoratorName(): String
    }
    
    class MultiAbsorbDecorator {
        +canMultiAbsorb(): boolean
        +getDecoratorName(): String
    }
    
    class ScoreMultiplierDecorator {
        -SCORE_MULTIPLIER: double
        +getScoreMultiplier(): double
        +getDecoratorName(): String
    }
    
    class RangeBoostDecorator {
        -RANGE_MULTIPLIER: double
        +getAbsorptionRange(): double
        +getDecoratorName(): String
    }
    
    PlayerAbility <|.. BasePlayerAbility
    PlayerAbility <|.. AbilityDecorator
    AbilityDecorator o--> PlayerAbility : wraps
    AbilityDecorator <|-- SpeedBoostDecorator
    AbilityDecorator <|-- ShieldDecorator
    AbilityDecorator <|-- MagnetDecorator
    AbilityDecorator <|-- MultiAbsorbDecorator
    AbilityDecorator <|-- ScoreMultiplierDecorator
    AbilityDecorator <|-- RangeBoostDecorator
}

' ========================================
'           COMPOSITE PATTERN
' ========================================
package "Composite Pattern" #LightYellow {
    
    interface ChamberComponent <<interface>> {
        +getName(): String
        +getX(): double
        +getY(): double
        +getWidth(): double
        +getHeight(): double
        +add(component: ChamberComponent): void
        +remove(component: ChamberComponent): void
        +getChildren(): List<ChamberComponent>
        +getAllEssences(): List<EssenceParticle>
        +getAllObstacles(): List<Obstacle>
        +getAllPowerUps(): List<PowerUp>
        +update(deltaTime: double): void
        +contains(x: double, y: double): boolean
    }
    
    class SimpleChamber {
        -name: String
        -x, y, width, height: double
        -essences: List<EssenceParticle>
        -obstacles: List<Obstacle>
        -powerUps: List<PowerUp>
        +addEssence(essence: EssenceParticle): void
        +addObstacle(obstacle: Obstacle): void
        +addPowerUp(powerUp: PowerUp): void
        +getAllEssences(): List<EssenceParticle>
    }
    
    class CompoundChamber {
        -name: String
        -children: List<ChamberComponent>
        -directEssences: List<EssenceParticle>
        -directObstacles: List<Obstacle>
        -directPowerUps: List<PowerUp>
        +add(component: ChamberComponent): void
        +remove(component: ChamberComponent): void
        +getChildren(): List<ChamberComponent>
        +getAllEssences(): List<EssenceParticle>
    }
    
    class EssenceParticle {
        -x, y: double
        -color: EssenceColor
        -points: int
        -collected: boolean
        +getColorHex(): String
        +collect(): void
        +isCollected(): boolean
    }
    
    class Obstacle {
        -x, y, width, height: double
        -type: ObstacleType
        -damage: int
        +update(deltaTime: double): void
        +collidesWith(x, y, radius: double): boolean
    }
    
    class PowerUp {
        -x, y: double
        -type: PowerUpType
        -collected: boolean
        +createDecorator(ability: PlayerAbility): AbilityDecorator
    }
    
    ChamberComponent <|.. SimpleChamber
    ChamberComponent <|.. CompoundChamber
    CompoundChamber o--> "*" ChamberComponent : children
    SimpleChamber --> "*" EssenceParticle
    SimpleChamber --> "*" Obstacle
    SimpleChamber --> "*" PowerUp
    CompoundChamber --> "*" EssenceParticle
    CompoundChamber --> "*" Obstacle
    CompoundChamber --> "*" PowerUp
}

' ========================================
'           OBSERVER PATTERN
' ========================================
package "Observer Pattern" #LightPink {
    
    interface GameObserver <<interface>> {
        +onGameEvent(event: GameEvent): void
    }
    
    class GameEvent {
        -type: EventType
        -data: Map<String, Object>
        -timestamp: long
        +getType(): EventType
        +getData(key: String): Object
        +getInt(key: String): int
        +getString(key: String): String
    }
    
    class "GameEvent.EventType" as EventType <<enum>> {
        GAME_STARTED
        GAME_PAUSED
        GAME_RESUMED
        GAME_OVER
        GAME_VICTORY
        LEVEL_STARTED
        LEVEL_COMPLETED
        PLAYER_DAMAGED
        PLAYER_HEALED
        PLAYER_DIED
        STATE_CHANGED
        ESSENCE_COLLECTED
        POWERUP_COLLECTED
        ABILITY_USED
        DECORATOR_ADDED
        DECORATOR_EXPIRED
        SCORE_CHANGED
        ...
    }
    
    class GameEventManager <<Singleton>> {
        -{static} instance: GameEventManager
        -observers: Map<EventType, List<GameObserver>>
        +{static} getInstance(): GameEventManager
        +subscribe(types: EventType[], observer: GameObserver): void
        +unsubscribe(observer: GameObserver): void
        +fireEvent(event: GameEvent): void
    }
    
    GameEventManager --> "*" GameObserver : notifies
    GameEventManager --> GameEvent : fires
    GameEvent --> EventType
}

' ========================================
'           ENTITY CLASSES
' ========================================
package "Entity" #LightGray {
    
    class Player {
        -x, y: double
        -currentState: ElementalState
        -abilities: PlayerAbility
        -decorators: List<AbilityDecorator>
        -health, maxHealth: int
        -score: int
        +transmuteToFire(): void
        +transmuteToWater(): void
        +transmuteToEarth(): void
        +transmuteToAir(): void
        +useSpecialAbility(): void
        +addDecorator(decorator: AbilityDecorator): void
        +canAbsorb(color: String): boolean
        +absorbEssence(essence: EssenceParticle): void
        +takeDamage(amount: int): void
        +update(deltaTime: double): void
    }
    
    Player --> ElementalState : currentState
    Player --> PlayerAbility : abilities
    Player --> "*" AbilityDecorator : decorators
}

' ========================================
'           MODEL & CONTROLLER
' ========================================
package "Model" #Lavender {
    
    class GameModel {
        -player: Player
        -currentLevel: Level
        -currentLevelNumber: int
        -gameState: GameState
        -levelTime: double
        +startGame(): void
        +pauseGame(): void
        +resumeGame(): void
        +update(deltaTime: double): void
        +checkCollisions(): void
        +nextLevel(): void
    }
    
    class Level {
        -levelNumber: int
        -name: String
        -rootChamber: ChamberComponent
        -recipes: List<Recipe>
        +getCompletionPercentage(): double
        +isCompleted(): boolean
    }
    
    class Recipe {
        -name: String
        -requirements: Map<EssenceColor, Integer>
        -collected: Map<EssenceColor, Integer>
        +addCollected(color: EssenceColor): void
        +isCompleted(): boolean
    }
    
    class LevelGenerator {
        +{static} generateLevel(levelNumber: int): Level
        -createTutorialLevel(): Level
        -createDualChambersLevel(): Level
        -createFourElementsLevel(): Level
        -createNestedChambersLevel(): Level
        -createFinalChallengeLevel(): Level
    }
    
    GameModel --> Player
    GameModel --> Level
    GameModel --> GameState
    Level --> ChamberComponent : rootChamber
    Level --> "*" Recipe
}

package "Controller" #Wheat {
    
    class GameController {
        -model: GameModel
        -view: GameView
        -gameLoop: AnimationTimer
        +startGameLoop(): void
        +stopGameLoop(): void
        +handleKeyPressed(code: KeyCode): void
        +handleKeyReleased(code: KeyCode): void
        +newGame(): void
        +pauseGame(): void
        +resumeGame(): void
    }
    
    GameController --> GameModel
    GameController ..|> GameObserver
}

' ========================================
'           VIEW
' ========================================
package "View" #PeachPuff {
    
    class GameApplication {
        -primaryStage: Stage
        -controller: GameController
        -gameView: GameView
        +start(stage: Stage): void
        +stop(): void
    }
    
    class GameView {
        -stage: Stage
        -controller: GameController
        -gameCanvas: Canvas
        -menuScene: Scene
        -gameScene: Scene
        -optionsScene: Scene
        +showMenuScene(): void
        +showGameScene(): void
        +showOptionsScene(): void
        +showGameOverScene(): void
        +showVictoryScene(): void
        +render(model: GameModel): void
    }
    
    GameApplication --> GameController
    GameApplication --> GameView
    GameView --> GameController
}

' ========================================
'           LOGGING (SINGLETON)
' ========================================
package "Logging" #Cyan {
    
    class GameLogger <<Singleton>> {
        -{static} instance: GameLogger
        -logger: Logger
        +{static} getInstance(): GameLogger
        +logInfo(message: String): void
        +logWarning(message: String): void
        +logError(message: String): void
        +logGameStateChange(from, to: String): void
        +logPlayerStateChange(from, to: String): void
        +logDecoratorAdded(name: String): void
        +logDecoratorExpired(name: String): void
        +logEntityCreated(type, name: String): void
        +logCollision(entity1, entity2: String): void
        +logLevelStarted(levelNumber: int): void
        +logLevelCompleted(levelNumber: int): void
        +logEvent(eventType: String): void
    }
}

' ========================================
'           RELATIONSHIPS
' ========================================
GameController ..> GameView
GameModel ..> GameEventManager
Player ..> GameEventManager
SimpleChamber ..> EssenceParticle
PowerUp ..> AbilityDecorator : creates
GameView ..> GameModel : renders

@enduml
